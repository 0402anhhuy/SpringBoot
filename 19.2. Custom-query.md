🎯 Tuyệt vời! Đây là bước **nâng cao và cực kỳ quan trọng** khi làm việc với Spring Data JPA:

> 📌 **Custom Query bằng `@Query` annotation** — cho phép bạn **viết truy vấn SQL/JPQL tùy chỉnh**, không phụ thuộc vào cách đặt tên hàm nữa.

---

# 📘 Giải thích chi tiết `@Query` trong Spring Data JPA

---

## ✅ 1. Mục đích của `@Query`

> Dùng khi bạn muốn **viết câu truy vấn tùy chỉnh** thay vì để Spring tự suy luận qua tên hàm.

✔ Hữu ích khi:

- Truy vấn phức tạp (join, group by, limit)
- Không thể diễn tả bằng tên hàm
- Cần dùng `JOIN`, `SUBQUERY`, `ORDER`, v.v.

---

## 📄 Ví dụ bạn đưa:

```java
@Query("SELECT p FROM Product p WHERE p.price > :min")
List<Product> findExpensive(@Param("min") double minPrice);
```

---

## 🧠 Giải thích từng phần:

| Thành phần                      | Ý nghĩa                                           |
| ------------------------------- | ------------------------------------------------- |
| `@Query(...)`                   | Viết truy vấn theo kiểu **JPQL**                  |
| `"SELECT p FROM Product p"`     | Chọn tất cả từ **entity `Product`**, alias là `p` |
| `WHERE p.price > :min`          | Điều kiện lọc: `price` lớn hơn giá trị `:min`     |
| `:min`                          | **Biến bind** (được gán từ `@Param("min")`)       |
| `@Param("min") double minPrice` | Tham số truyền vào từ method                      |

---

### 🔍 Lưu ý: Đây là **JPQL**, không phải SQL ❗

| JPQL (Java Persistence Query Language) | SQL truyền thống           |
| -------------------------------------- | -------------------------- |
| Dùng tên **entity** và **field**       | Dùng tên bảng và cột       |
| `Product`, `price`                     | `product`, `product_price` |
| `SELECT p FROM Product p`              | `SELECT * FROM product`    |

---

## ✅ Kết quả:

👉 Khi bạn gọi:

```java
findExpensive(100.0);
```

➡️ Hibernate sẽ sinh ra truy vấn:

```sql
SELECT * FROM product WHERE price > 100.0;
```

✅ Kết quả là danh sách `Product` có `price > 100.0`

---

## ✅ 2. Cách truyền biến trong `@Query`

| Cách                     | Cú pháp                 | Ghi chú           |
| ------------------------ | ----------------------- | ----------------- |
| **Named parameter**      | `:min`, `@Param("min")` | ✅ Khuyên dùng    |
| **Positional parameter** | `?1`, `?2`              | Không cần đặt tên |

---

## ✅ 3. Có thể dùng với nhiều điều kiện

```java
@Query("SELECT p FROM Product p WHERE p.name LIKE %:keyword% AND p.price BETWEEN :min AND :max")
List<Product> search(@Param("keyword") String keyword,
                     @Param("min") Double min,
                     @Param("max") Double max);
```

---

## ✅ 4. Native SQL query

> Khi cần truy vấn **SQL chuẩn** (không qua entity), bạn dùng:

```java
@Query(value = "SELECT * FROM product WHERE price > :min", nativeQuery = true)
List<Product> rawQuery(@Param("min") double min);
```

---

## ✅ 5. Tóm tắt

| Ưu điểm `@Query`                          | ✅  |
| ----------------------------------------- | --- |
| Viết truy vấn tùy chỉnh                   | ✔️  |
| Truy vấn phức tạp (join, sort, limit,...) | ✔️  |
| Có thể dùng SQL thật (native)             | ✔️  |
| Kết hợp dễ với `@Param`                   | ✔️  |

---

## ⚠️ Lưu ý

| Cẩn thận                                      | Vì sao                               |
| --------------------------------------------- | ------------------------------------ |
| Sai tên entity hoặc field → lỗi runtime       | JPQL dùng class, không dùng tên bảng |
| Không truyền đúng tên `@Param(...)`           | Gây lỗi query không bind biến        |
| Nên test truy vấn kỹ trước khi đưa production | ✔️                                   |

---

📌 Bạn muốn mình viết:

- Một `@Query` dùng `JOIN`
- Một custom query lọc sản phẩm theo nhiều tiêu chí (keyword + price + category)?

👉 Chỉ cần nói **“Làm query nâng cao với join”**, mình build cho bạn luôn nhé 🔧🤖
